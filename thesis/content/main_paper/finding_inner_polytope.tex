\subsection{\texorpdfstring{$\forall$}{For all}-Elimination}

The first approach is the computationally less expensive one, but comes in cost with smaller resulting set, but is it turn it does still perform
really well.
The idea is to find intervals for the variables of interest namely $\dot{s}$, $u_t$ and $u_n$ such that for the values variables may take from those
intervals the implications from \ref{eq:forall_formula} holds.
Each of the condition of that implications follow the following pattern.
Let $x \in \{\dot{s}, u_t, u_n\}$ and $y$ a vector containing the remaining variables are part of the condition.
\begin{equation}
	\label{eq:cur_condition}
	c_{min} \leq f(x, y) \leq c_{max}
\end{equation}
with $x \in \mathbb{R}$, $y \in \mathbb{R}^n$, and $f: \mathbb{R}^{n+1} \to \mathbb{R}$, where $c_{min}, c_{max} \in \mathbb{R}$ are constants.
$x$ is chosen such that all the remaining variables contained in $y$ are bounded.
Further, $x$ is chosen such that $f$ is affine in $x$, represented by:
\begin{equation}
	f(x, y) = a(y) x + b(y)
\end{equation}
with $a, b : \mathbb{R}^n \to \mathbb{R}$, since $a$ and $b$ are continues functions over a bounded domain $Y$ one can find bounds on $a(y)$ and $b(y)$:
\begin{equation}
	a_{min} \leq a(y) \leq a_{max}, \quad b_{min} \leq b(y) \leq b_{max}
\end{equation}
Our goal is to find an interval $[\underline{x}, \overline{x}]$ for $x$ such that
\begin{equation}
	x\in [\underline{x}, \overline{x}] \implies \forall y\in Y: c_{min} \leq f(x, y) \leq c_{max}
\end{equation}

We define $X := [\underline{x}, \overline{x}]$.
We can calculate $X$ with a case distinction over the possible signs $a(y)$ may take.
Let's start with

\textbf{1.
}
$a(y) > 0$:
We can subtract \ref{eq:cur_condition} with $b(y)$ and divide by $a(y)$:
\[
	\frac{c_{min}-b(y)}{a(y)} \leq x \leq \frac{c_{max}-b(y)}{a(y)}
\]
Since we have to ensure the condition holds even in the worst case, $X$ is given by:
\[
	\underline{x} =
	\begin{cases}
		\begin{array}{ll}
			\frac{c_{min}-b_{min}}{a_{max}}, & \text{if } c_{min}-b_{min} < 0 \\[10pt]
			\frac{c_{min}-b_{min}}{a_{min}}, & \text{otherwise}
		\end{array}
	\end{cases}
\]
\[
	\overline{x} =
	\begin{cases}
		\begin{array}{ll}
			\frac{c_{max}-b_{max}}{a_{min}}, & \text{if } c_{max}-b_{max} < 0 \\[10pt]
			\frac{c_{max}-b_{max}}{a_{max}}, & \text{otherwise}
		\end{array}
	\end{cases}
\]

\textbf{2.}
$a(y) \geq 0$:
Since $a(y) = 0$ for some $y\in Y$, we have to test if this condition holds:
\[
	c_{min} \leq b_{min} \text{ and } b_{max} \leq c_{max}
\]
if it does not hold $X$ is given by $X=\emptyset$, and otherwise we exclude all $y\in Y$ for which $a(y)=0$ and go to the first case.

\textbf{3.}
$a(y) < 0$:
We can again subtract $b(y)$ from \ref{eq:cur_condition} and divide by $a(y)$, but the directions of the inequalities changes this time:
\[
	\frac{c_{max}-b(y)}{a(y)} \leq x \leq \frac{c_{min}-b(y)}{a(y)}
\]
and by looking at the worst cases of the lower and upper bound we can calculate $X$:
\[
	\underline{x} =
	\begin{cases}
		\begin{array}{ll}
			\frac{c_{max}-b_{max}}{a_{max}}, & \text{if } c_{max}-b_{max} < 0 \\[10pt]
			\frac{c_{max}-b_{max}}{a_{min}}, & \text{otherwise}
		\end{array}
	\end{cases}
\]
\[
	\overline{x} =
	\begin{cases}
		\begin{array}{ll}
			\frac{c_{min}-b_{min}}{a_{min}}, & \text{if } c_{min}-b_{min} < 0 \\[10pt]
			\frac{c_{min}-b_{min}}{a_{max}}, & \text{otherwise}
		\end{array}
	\end{cases}
\]

\textbf{4.}
$a(y) \leq 0$:
similar to the second case we have to if $c_{min} \leq b_{min} \text{ and } b_{max} \leq c_{max}$ holds, if not $X=\emptyset$ else we ignore the values for $a(y)$ takes the value zero and go to third case.

\textbf{5.}
We have so far considered all the cases where $a(x)$ can not take both positive and negative values, we remain with the last case, where $a_{min}<0$
and $0<a_{max}$.
Since $a(y)=0$ for some values we check $c_{min} \leq b_{min} \text{ and } b_{max} \leq c_{max}$ and set $X=\emptyset$ if it does not hold, otherwise
$X$ is given by:

\[ \underline{x} = \max \left\{ \frac{c_{min} - b_{min}}{a_{max}}, \frac{c_{max} - b_{max}}{a_{min}} \right\} \]

\[ \overline{x} = \min \left\{ \frac{c_{max} - b_{max}}{a_{max}}, \frac{c_{min} - b_{min}}{a_{min}} \right\} \]

If we end up with $x_{max} < x_{min}$, set $X=\emptyset$.

All of this applies nicely to our scenario, since one can go step by step through the constraints and apply these rules.
Of course the resulting Polytope is of a box shape based on the interval approach and therefore reduces our set of possible state variables and
control inputs further.

\subsection{Evaluation of the Inner Polytope}

We start by defining the intervals for the state variables and control inputs:
\begin{align*}
	0  & \leq s \leq 10,     \\
	0  & \leq n \leq 2,      \\
	-2 & \leq \dot{n} \leq 2
\end{align*}

We set $C(s) = \frac{1}{400}$ constant.
Next, we plug in concrete values for the upper and lower bounds of the constraints:
\begin{align*}
	0               & \leq \dot{s}(1 - nC(s)) \leq 10,            \\
	-5              & \leq C(s) \dot{s} \leq 5,                   \\
	-2              & \leq C'(s) \dot{s}^2 + C(s) u_t \leq 2,     \\
	\begin{bmatrix}
		-3 \\ -4
	\end{bmatrix} & \leq g(x_{tn}, \tilde{u}) \leq \begin{bmatrix}
		                                               6 \\ 4
	                                               \end{bmatrix}.
\end{align*}

Applying the approach outlined above, we can determine the intervals for $\dot{s}$, $u_t$, and $u_n$ that satisfy the constraints.
\begin{align*}
	0     & \leq \dot{s} \leq 10 \\
	-2.9  & \leq u_t \leq 5.9    \\
	-3.99 & \leq u_n \leq 3.75
\end{align*}

\section{Cylindrical Algebraic Decomposition}

% https://pdf.sciencedirectassets.com/272313/1-s2.0-S0747717120X00034/1-s2.0-S0747717119300859/main.pdf?X-Amz-Security-Token=IQoJb3JpZ2luX2VjEGEaCXVzLWVhc3QtMSJHMEUCIQDv1oLeMw%2BnRWE0h7eQREn2av5%2Fyma7r75pKvvjSHlrXwIgV7nFb3g04oCEggSau0SfQkIX7JmFrWaGLYqigDP09qwqvAUIiv%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FARAFGgwwNTkwMDM1NDY4NjUiDLCCP%2B5UfB4z%2F9ZIdiqQBQ7ZhV1OWpdCAEagdXayFOLycbob6NgxpF3z1LcaO5LcnynbNCjIKVBEA2QYuDnScIYeJxkFH6YYFi9ph8XVV3LjzYoAzcX4EU%2B1a1CzJpd2b%2F%2B1b4UukWAcQGXtUYi%2FLRVKDyoNr9CRPVmeu3ELpNmykuQQnJYzCLwsJSUc9ExIdZ8a%2BeQa3cjRFcVni7K%2BnFhH%2Fq%2Fy8P0WW4qt%2F1Hh48UXm2c8wSRTSXpaxOUeZLJzr4WbqT5jUQJsdLwfNCawDcAQrfoDGmtGnKiGS%2B03IulLdq5kKFvEcg8VzoT2zCl2geVu%2BxWFtuwkspvAX%2FVoyRDUeqEpfWkd1Ow2hK%2FFd6xoLEBc6ER4A6leFr5%2FE8wtKfvCDnNqH7G24pUVllhuuT1Vo4GyMHKsbobZbZc9aenU6gpDDoXAc0Pn0JSUTo8zL%2FZCdOqIdVFGbkWPE9sGjWjoFJbHwqudjGZdRYGFekI%2BgsqEu2l1J9AtmTVsr8zLaAQ43%2FUJGR4v8TE%2F05QmO93bo7IkSrsF3OZ4wQPalWuqcyvm6aTa3YsWooRV7q1jc3KMsuMVei9IMFn2gdkUZDATKuYLuZWBs6zwvbVXC0Z7bq6PWH2JHTQdVIxQxsmBSfaV3YOa%2BI3hl5zBNeSAfoDXEEImdqLUsw06mmUvy2IP%2Bzt95a%2FA8Cp9U1yGLmYJZu83DaEnHHVAJ7scbh9c1itOliyghGaTuLzyZi3JbQJB7HW6Put0XOt7zpBHU0NzO7UpQWq%2FTzmHSUSSSkey821Yz%2BFjqciZsQuhzwiOvqHDimSa0kJmeMbpjC5YKax0BOCWjST1UD%2FMnguAu1yTvZS6NrWkCqd7x5bQl3cDg5DSNm2VWTg%2FkZx4JUOZmLxqMKiM0b0GOrEBKzrzEOw7KtIOIpTMjE%2Bs2GvYtsAhgwXJiN5L0r%2FLXqOg6%2B1c%2FNqDSsVeNzrG%2FIH7FgIVEi3BlBViJT9jkjRXQlb0eBFchDzGXKYxs6Cd3S3IOuznUnycfU4IkP5RTiH8ezMEpJ8kCPHRxMrFsjZjLzwTnyBJQrmoztOqL9NSJ7oOjHhKzntHaI9XbPAqb17bMrsnqgR1hppRBXBtCNuJ2CXGgTf8O5OJJSLuZHeyuk1b&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Date=20250218T085718Z&X-Amz-SignedHeaders=host&X-Amz-Expires=300&X-Amz-Credential=ASIAQ3PHCVTYZ3CJJ6RU%2F20250218%2Fus-east-1%2Fs3%2Faws4_request&X-Amz-Signature=773e914dc853ee1f296df8ec3ecf005187519e5ef698f2c1f9146864c5cb004a&hash=1f88efcdfe5ff01d947ced0dcd867ca316abe9378c414f7a661aa7397787d115&host=68042c943591013ac2b2430a89b270f6af2c76d8dfd086a07176afe7c76c2c61&pii=S0747717119300859&tid=spdf-619c46db-0fd6-4248-b3db-2dbf2175b738&sid=3036b6bb946a2440116b8422b092c52ae3aagxrqb&type=client&tsoh=d3d3LnNjaWVuY2VkaXJlY3QuY29t&ua=02075c54500504035f53&rr=913ccf147b209248&cc=de

The second approach is to use Cylindrical Algebraic Decomposition (CAD) to find the inner polytope.
This method is computationally more expensive but provides a more accurate result.
The idea is to find for a given formula (containing quantifier) an equivalent formula without quantifiers, which will contain only the free variables
that are not bound to a quantifier.
This can be done by using CAD.

CAD is a method used in computer algebra for solving systems of polynomial equations and inequalities.
Let's say you have a set of polynomial equations and inequalities.
If one applies CAD to this set, it will decompose the space into a finite number cylindrical cells.
Each cell is described by a sequence of polynomial inequalities.
The cells have the property that they have a constant truth value over the input set of polynomial equations and inequalities.
This way one has to only pick one point from each cell to check the truth value of the input set of polynomial equations and inequalities.
The number of cells grows doubly exponentially with the number of variables in the input set of polynomial equations and inequalities.
For CAD exist several implementations.

We are going to illustrate how the Algorithm works and it is not scope of this work to explain the implementations.
Instead, we are giving you a toolbox how one can do it.

\subsubsection{Example}
Since we are focusing on eliminating $\forall$ quantifiers, we will tackle the following problem:

\[ \forall x, x^2 + bx + 1 \geq
	0 \]

Since the Quantifier Elimination problem is usually done the on an existential quantifier, we first solve the problem for \[
	\exists x, x^2 + bx + 1 < 0 \] and once we have the solution for this problem we can take the compliment over $\mathbb{R}$ to get the solution for
the original problem.
The first thing is to extract is to apply CAD to the polynomial $x^2 + bx + 1$, which results in 7 cells illustrated in the figure
\ref{fig:example_cells}.
Most of the cells are open and if the edge of the cell is part of it then it is depicted dashed with the same color.

\begin{figure}[h]
	\centering
	\definecolor{redviolet}{rgb}{0.78, 0.08, 0.52}
	\begin{tikzpicture}
		\begin{axis}[
				xlabel={$b$},
				ylabel={$x$},
				axis lines=middle,
				enlargelimits=true,
				legend pos=north west,
			]

			% Define the boundaries as paths
			\addplot [name path=RightUpper, domain=2:5, samples=100, thick, redviolet!30, dashed] {-(x/2) + 1/2 * sqrt(-4 + x^2)};
			\addplot [name path=RightLower, domain=2:5, samples=100, thick, teal!30, dashed] {-(x/2) - 1/2 * sqrt(-4 + x^2)};
			\addplot [name path=LeftUpper, domain=-5:-2, samples=100, thick,blue!30, dashed] {-(x/2) + 1/2 * sqrt(-4 + x^2)};
			\addplot [name path=LeftLower, domain=-5:-2, samples=100, thick,cyan!30, dashed] {-(x/2) - 1/2 * sqrt(-4 + x^2)};

			% Define vertical lines as paths but make them invisible
			\addplot [name path=lineInnerRight,dashed, thick,  red!30] coordinates {(2,-5) (2,5)};
			\addplot [name path=lineInnerLeft, dashed, thick, red!30] coordinates {(-2,-5) (-2,5)};

			% Define horizontal boundaries as paths but make them invisible
			\addplot [name path=lineUpperLeft, draw=none] coordinates {(-5,5) (-2,5)};
			\addplot [name path=lineUpperRight, draw=none] coordinates {(2,5) (5,5)};
			\addplot [name path=lineLowerLeft, draw=none] coordinates {(-5,-5) (-2,-5)};
			\addplot [name path=lineLowerRight, draw=none] coordinates {(2,-5) (5,-5)};

			% Region 1: b>2, x >= -(b/2) + 1/2 sqrt(-4 + b^2)
			\addplot [fill=redviolet!30, opacity=0.5] fill between[of=RightUpper and lineUpperRight];

			% % Region 2: b>2, x <= -(b/2) - 1/2 sqrt(-4 + b^2)
			\addplot [fill=teal!30, opacity=0.5] fill between[of=RightLower and lineLowerRight];

			% % Region 3: b<-2, x >= -(b/2) + 1/2 sqrt(-4 + b^2)
			\addplot [fill=blue!30, opacity=0.5] fill between[of=LeftUpper and lineUpperLeft];

			% % Region 4: b<-2, x <= -(b/2) - 1/2 sqrt(-4 + b^2)
			\addplot [fill=cyan!30, opacity=0.5] fill between[of=LeftLower and lineLowerLeft];

			% % Region 5: -2 ≤ b ≤ 2 (rectangle covering all x values)
			\addplot [fill=red!30, opacity=0.5] fill between[of=lineInnerLeft and lineInnerRight];

			% % Region 6: b>2, x > -(b/2) - 1/2 Sqrt[-4+b^2], x < -(b/2) + 1/2 Sqrt[-4+b^2]
			\addplot [fill=cyan!30, opacity=0.3] fill between[of=RightUpper and RightLower];

			% % Region 7: b<-2, x > -(b/2) - 1/2 Sqrt[-4+b^2], x < -(b/2) + 1/2 Sqrt[-4+b^2]
			\addplot [fill=gray!30, opacity=0.3] fill between[of=LeftUpper and LeftLower];

		\end{axis}
	\end{tikzpicture}
	\caption{Illustrating the cells with shaded regions.}
	\label{fig:example_cells}
\end{figure}

We now have to check the truth value of the polynomial inequality $x^2 + bx + 1 < 0$ for each cell, by picking one random sample and evaluating the
inequality.
The cells with a truth value of true colored in green then get project the $b$-axis.
The resulting intervals are the result of the existential quantifier elimination $(-\infty, -2) \cup (2, \infty)$.
As an input of the Algorithm one has to define an order of precedence for the variables.
The algorithm in its first phase projects the space iterative from $\mathbb{R}^n$ to $\mathbb{R}^{n-1}$ until it reaches $\mathbb{R}^1$.
This is done by removing one of the remaining variables in each iteration which is last in the order of precedence.
Therefor if one defines $b$ as the first variable, the sets of polynomial inequalities of each cell will always contain an interval for $b$, which is
the corresponding projection on the axis.
This allows to just read the resulting intervals.

\begin{figure}[h]
	\centering
	\begin{tikzpicture}
		\begin{axis}[
				xlabel={$b$},
				ylabel={$x$},
				axis lines=middle,
				enlargelimits=true,
				legend pos=north west,
			]

			% Define the boundaries as paths
			\addplot [name path=RightUpper, domain=2:5, samples=100, thick, black!30, dashed] {-(x/2) + 1/2 * sqrt(-4 + x^2)};
			\addplot [name path=RightLower, domain=2:5, samples=100, thick, black!30, dashed] {-(x/2) - 1/2 * sqrt(-4 + x^2)};
			\addplot [name path=LeftUpper, domain=-5:-2, samples=100, thick,black!30, dashed] {-(x/2) + 1/2 * sqrt(-4 + x^2)};
			\addplot [name path=LeftLower, domain=-5:-2, samples=100, thick,black!30, dashed] {-(x/2) - 1/2 * sqrt(-4 + x^2)};

			% Define vertical lines as paths but make them invisible
			\addplot [name path=lineInnerRight,dashed, thick,  draw=none] coordinates {(2,-5) (2,5)};
			\addplot [name path=lineInnerLeft, dashed, thick, draw=none] coordinates {(-2,-5) (-2,5)};

			% Define horizontal boundaries as paths but make them invisible
			\addplot [name path=lineUpperLeft, draw=none] coordinates {(-5,5) (-2,5)};
			\addplot [name path=lineUpperRight, draw=none] coordinates {(2,5) (5,5)};
			\addplot [name path=lineLowerLeft, draw=none] coordinates {(-5,-5) (-2,-5)};
			\addplot [name path=lineLowerRight, draw=none] coordinates {(2,-5) (5,-5)};

			% % Region 6: b>2, x > -(b/2) - 1/2 Sqrt[-4+b^2], x < -(b/2) + 1/2 Sqrt[-4+b^2]
			\addplot [fill=green!30, opacity=0.3] fill between[of=RightUpper and RightLower];

			% % Region 7: b<-2, x > -(b/2) - 1/2 Sqrt[-4+b^2], x < -(b/2) + 1/2 Sqrt[-4+b^2]
			\addplot [fill=green!30, opacity=0.3] fill between[of=LeftUpper and LeftLower];

			\node[circle,draw,inner sep=1pt, green!60] (openCircleRight) at (axis cs:2,0) {};
			\draw[thick, green!60] (openCircleRight) -- (axis cs:5.5,0);
			\node[circle,draw,inner sep=1pt, green!60] (openCircleLeft) at (axis cs:-2,0) {};
			\draw[thick, green!60] (openCircleLeft) -- (axis cs:-5.5,0);
		\end{axis}
	\end{tikzpicture}
	\caption{Illustrating the remaining cells.}
	\label{fig:remaining_cells}
\end{figure}

Since $(-\infty, -2) \cup (2, \infty)$ is an equivalent formula for $\exists x, x^2 + bx + 1 < 0$, the solution for the original problem is given by
negotiate both formulas.

\[
	\forall x, x^2 + bx + 1 \geq 0 \iff b \in [-2, 2]
\]

Using this technique for eliminating quantifiers of formulas, we can apply it to our of finding an inner polytope.

\subsection{Compare both Approaches}

During our benchmarks, the first approach, despite its simplicity, performed remarkably well.
We used the following parameters for the benchmarks:
\begin{itemize}
	\item $C(s) \in \left[-\frac{1}{200}, 0\right]$
	\item $s \in [0, 10]$
	\item $n \in [0, 2]$
	\item $v_x \in [0, 10]$
	\item $v_y \in [-2, 2]$
	\item $a_x \in [-3, 6]$
	\item $a_y \in [-4, 4]$
	\item $\dot{\psi} \in [-5, 5]$
	\item $a_\psi \in [-2, 2]$
\end{itemize}

The results are shown in the following figures.

\begin{figure}[h]
	\centering
	% First image
	\begin{subfigure}[b]{0.32\textwidth}
		\centering
		\includegraphics[width=\textwidth]{content/main_paper/region_x3u1_plot_gr1.eps}
	\end{subfigure}
	% Second image
	\begin{subfigure}[b]{0.32\textwidth}
		\centering
		\includegraphics[width=\textwidth]{content/main_paper/region_x3u2_plot_gr1.eps}
	\end{subfigure}
	% Third image
	\begin{subfigure}[b]{0.32\textwidth}
		\centering
		\includegraphics[width=\textwidth]{content/main_paper/region_u1u2_plot_gr1.eps}
	\end{subfigure}

	\caption{In Green our first approach and in Blue using CAD.}
\end{figure}

In conclusion, eliminating the quantifiers with the first approach leads to a near-optimal result, comparable to the one achieved using the second
approach with CAD.
However, using CAD has a significant downside that we have not yet mentioned.
It is not guaranteed that the resulting formula is convex.
Typically, you will encounter disjunctions of polynomial inequalities, which cannot be handled by a convex solver without resorting to integer
programming or an equivalent approach.
It is also not guaranteed that each polynomial inequality adheres to the DCP rules, even if the set described by the resulting formula is convex.
Additional techniques would be required to use the second approach for our planner.

In cases where the resulting set is convex, we used a sampling approach to obtain an inner approximation described by half-spaces.
This results in a sequence of linear constraints that all must be satisfied, thus losing a small proportion of the original set.
Consequently, the difference between our first approach and the second approach becomes even smaller.
Additionally, we end up with double or triple the number of constraints on each state variable and each control input, which may lead to slower
solver times.

Overall, while the CAD approach provides a more accurate result, the first approach offers a good balance between computational efficiency and
accuracy, making it a viable option for practical applications.

\subsection{Inner Polytope}

We have managed to construct a realistic model, which allows us to model any constraints arising either from the vehicle dynamics or the environment,
such that they are not only confirm with the DCP rules but also linear.

Our inner polytope from the problem \ref{problem:inner_polytope} is now given by:

\begin{equation}
	\underline{\mathcal{C}} = \tilde{\underline{\mathcal{C}}} \times [\underline{s}, \overline{s}] \times [\underline{n}, \overline{n}] \times [\underline{\dot{n}}, \overline{\dot{n}}]
\end{equation}
with $\tilde{\underline{\mathcal{C}}}$ resulting from $\forall$-elimination.

\subsection{Limitations and Outlook}

While the $\forall$-elimination approach provides a computationally efficient method to find intervals for the variables of interest, it can be quite restrictive for several reasons:

\begin{itemize}
	\item \textbf{Conservativeness:}
	      The approach tends to be conservative because it ensures that the constraints hold for all possible values within the intervals.
	      This often leads to smaller intervals, which may exclude feasible solutions that could be considered by less conservative methods.
	\item \textbf{Dependence on Affine Functions:}
	      The method relies on the assumption that the function $f(x, y)$ is affine in $x$.
	      If this assumption does not hold, the approach may not be applicable or may yield inaccurate results.
	\item \textbf{Worst-Case Scenarios:}
	      The intervals are determined based on worst-case scenarios, which can be overly pessimistic and exclude feasible solutions that are not captured by
	      the worst-case analysis.
\end{itemize}

Overall, while the $\forall$-elimination approach is useful for its simplicity and computational efficiency, it may lead to overly restrictive
solutions that do not fully exploit the feasible region.

Imagine your scenario consists of a tight turn and long straight road.
In such scenarios, the model, will restrict $\dot{s}$ to an interval that is valid for both the tight turn and the straight road.
One can easily imagine that model will find a result, but it will not be able to drive fast on the straight road, then it is possible to drive on
tight the turn.

Solving such issues can be done by introducing segments of the road, one for the straight road and one for the tight turn.
We can independently construct the coupling constraints set for each segment.
But this leads to a new Problem, how to switch between the segments.
We have come up with a solution where we use the current vehicle velocity to predict at which time the vehicle will reach the end of the segment.
Since one knows the vehicles current position, velocity and the distance to the end of the segment, one can calculate the time it will take to reach.

What both approaches both do not consider and may lead to a far larger set, if you would restrict $\dot{n}$ for example to a smaller interval.
The first approach handles the problem by using the bounds on $s$, $n$ and $\dot{n}$ to find the intervals for $\dot{s}$, which then is used for
$u_t$ and finally for $u_n$.
But changing the order may lead to better results for desired driving behavior.

Since the first approach is so simple we implemented a non-linear program which defines the relations between the intervals that arise with variables
as upper and lower bounds.
Constraining them additional we can define an objective that can model certain driving behavior.
As for example one should be able to slow down as quickly as possible, or the upper speed limit should as large as possible.
The latter one leads for example to the following intervals.

\begin{figure}[h]
	\centering
	\begin{subfigure}[b]{0.45\textwidth}
		\centering
		\begin{align*}
			0    & \leq s \leq 10       \\
			0    & \leq n \leq 2        \\
			0    & \leq \dot{s} \leq 10 \\
			-2   & \leq \dot{n} \leq 2  \\
			-2.9 & \leq u_t \leq 5.9    \\
			-4   & \leq u_n \leq 3.75
		\end{align*}
		\caption{Initial Approach}
	\end{subfigure}
	\hfill
	\begin{subfigure}[b]{0.45\textwidth}
		\centering
		\begin{align*}
			0      & \leq s \leq 10,         \\
			0      & \leq n \leq 2,          \\
			0      & \leq \dot{s} \leq 10.05 \\
			-2     & \leq \dot{n} \leq 2     \\
			-2.899 & \leq u_t \leq 5.929     \\
			-4     & \leq u_n \leq 3.746
		\end{align*}
		\caption{Using Non-Linear Programming}
	\end{subfigure}
	\caption{Comparison of two sets of intervals for state variables and control inputs.}
\end{figure}

As you can see the intervals on the right could be considered better, since one only loses a bit off longitudinal acceleration, but therefore can
driver faster.

But nevertheless, we managed to build our first vehicle model for motion planning, which can be solved by convex solver.
We will now increase the complexity for the next model, in which we will tackle the problem of introducing a vehicle orientation and a steering angle
during the planning.
This will allow us to get a more realistic trajectory for the vehicle, especially for lower speeds and turns.
