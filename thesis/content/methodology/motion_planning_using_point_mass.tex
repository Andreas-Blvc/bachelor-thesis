\section{Motion Planning Using Point Mass} \label{sec:motion_planning_using_point_mass}

In Section \ref{section:basic_pm}, we introduced the point mass model with global coordinates and no orientation.
We now extend this model to the Frenet frame, which allows for a more structured approach to motion planning along a predefined road.

To achieve this, we first define the curvature of the reference path, which quantifies the rate of change of the tangent angle with respect to arc length:
\begin{equation}
	C := \frac{d\theta}{ds}.
\end{equation}
Additionally, let $\psi$ be the orientation of the vehicle, and define the alignment error $\xi$ as the difference between the vehicle's orientation and the reference path's tangent angle:
\begin{equation}
	\xi := \psi - \theta.
\end{equation}
This alignment error measures the deviation of the vehicle's heading from the reference path.

Using these definitions, along with established kinematic relationships and coordinate frame transformations, we can systematically derive the motion
dynamics in the Frenet frame.
These equations describe how the vehicle's velocity components in the body-fixed frame relate to changes in Frenet frame coordinates.

The first-order derivatives are given by:
\begin{align}
	\dot{s}(1 - nC(s)) & = v_x\cos{\xi} - v_y\sin{\xi}, \label{eq:first_derivative_long} \\
	\dot{n}            & = v_x\sin{\xi} + v_y\cos{\xi}. \label{eq:first_derivative_lat}
\end{align}

These equations describe the evolution of the vehicle's longitudinal and lateral positions in the Frenet frame.
The presence of the curvature term $C(s)$ ensures that the equations correctly account for the curvature of the reference path.

For the second derivatives, we obtain:
\begin{align}
	a_{x,tn} & = (a_x - v_y\dot{\psi})\cos{\xi} - (a_y + v_x\dot{\psi})\sin{\xi}, \label{eq:second_derivative_long} \\
	a_{y,tn} & = (a_x - v_y\dot{\psi})\sin{\xi} + (a_y + v_x\dot{\psi})\cos{\xi}. \label{eq:second_derivative_lat}
\end{align}

where the transformed acceleration terms in the Frenet frame are given by:
\begin{align}
	a_{x,tn} & := \ddot{s}(1 - nC(s)) - 2\dot{n}
	C(s)\dot{s} - nC'(s)\dot{s}^2, \label{def:axtn} \\ a_{y,tn} & := \ddot{n} + C(s)\dot{s}^2(1 - nC(s)).
	   \label{def:aytn}
\end{align}

These expressions incorporate the effects of curvature and alignment, ensuring that motion planning remains accurate and consistent with the road
geometry.
In subsequent sections, we will leverage these equations to develop motion planning strategies that optimize trajectory feasibility and control
performance.

\subsection{Conversion of Global Cartesian Coordinates to Frenet Frame Coordinates} \label{subsec:pm_conversion_of_cartesian_to_frenet}

We now define the state variables $x_{tn}$, which represent the vehicle's position, orientation, and velocities in the Frenet frame, and control inputs $u_{tn}$ for our point mass model in the Frenet frame:

\begin{equation}
	x_{tn} = \begin{bmatrix}
		s       \\
		n       \\
		\xi     \\
		\dot{s} \\
		\dot{n} \\
		\dot{\psi}
	\end{bmatrix}
\end{equation}

The state vector consists of the Frenet frame coordinates that define the vehicle's location, the alignment error representing the deviation of the
vehicle's orientation from the reference path, and the first-order time derivatives of these quantities, which capture the vehicle's velocity
components.

We define the following three control inputs:

\begin{equation}
	u_{tn} = \begin{bmatrix}
		a_{x} \\
		a_{y} \\
		a_\psi
	\end{bmatrix}
\end{equation}

Using the previously derived equations, we can formulate the model dynamics in the Frenet frame as:

\begin{equation}
	\label{eq:frenet_frame_pm_dynamics}
	f_{tn}(x_{tn}, u_{tn}) = \begin{bmatrix}
		\dot{s}                                   \\
		\dot{n}                                   \\
		\dot{\psi} - C(s)\dot{s}                  \\
		\frac{ a_{x,tn} + 2\dot{n}
		C(s)\dot{s}+nC'(s)\dot{s}^2 } { 1-nC(s) } \\ a_{y,tn} - C(s)\dot{s}^2(1-nC(s)) \\ a_\psi\end{bmatrix} \end{equation}

With this
formulation, we are now able to model vehicle motion in the Frenet frame along a predefined road.
This approach facilitates the definition of road topology constraints in a straightforward manner, ensuring that the resulting constraints align with
the principles of disciplined convex programming (DCP).
However, the inclusion of curvature terms introduces non-convexity into the system dynamics.
In the following section, we will explore methods to address this challenge and develop techniques to handle the resulting non-convex constraints
effectively.

\subsection{Constraints} \label{subsec:constraints}

First thing we are going to do is that we decouple the input.
If you take a look at the dynamics equations \ref{eq:frenet_frame_pm_dynamics}, the last two entries both contain the control input $a_x$, $a_y$ if
you plug in the equations \ref{def:axtn} and \ref{def:aytn}.
By making the following Assumption.

\subsubsection{Assumption: Alignment Error}

Orientation of the vehicle $\psi$ equals the angle of the road $\theta$:
\begin{equation}
	\xi = \psi - \theta = 0
\end{equation}
which directly implies the following three points, which will help us in further steps:
\begin{itemize}
	\item $[a_x, a_y] = [a_{x,tn}, a_{y,tn}]$
	\item $\dot{\psi} = \dot{\theta} = \frac{d\theta}{ds} \cdot \frac{ds}{dt} = C(s)\dot{s}$
	\item $a_\psi = \ddot{\psi} = \ddot{\theta} = C'(s) \dot{s}^2 + C(s)\ddot{s}$
\end{itemize}

At first glance seems like we are removing the orientation from our model, but we actually just force the vehicle to always be aligned with the road.
And since we allow lateral acceleration of the vehicle, it is not fixed to a constant offset to the reference and can still move left or right.
Once the trajectory has been planned we let further layers handle the problem of finding the correct control namely steering and longitudinal
acceleration for the vehicle, this will be based on more complex models.

With this assumption we end up with dynamics equation, which are affine linear in $a_{x,tn}$ and $a_{y,tn}$.
(TODO EXPLAIN WHY).
This allows us to introduce artificial control inputs to linearize the dynamics.
\begin{equation}
	\label{def:artificial_controls}
	\tilde{u} := \begin{bmatrix}
		u_t \\
		u_n
	\end{bmatrix} = \begin{bmatrix}
		\frac{
			a_{x,tn} + 2\dot{n}
		C(s)\dot{s} + nC'(s)\dot{s}^2 }{ 1 - nC(s) } \\ a_{y,tn} - C(s)\dot{s}^2(1 - nC(s))\end{bmatrix} \end{equation}

In summary, by
fixing one state variable, which leads to slightly less realistic vehicle model, but which led to affine linear dynamics in the controls inputs.
This enabled us to introduce artificial variables, which linearizes the dynamics entirely as follows.

\subsubsection{Resulting Simplified Model}

Since the orientation is fixed, we can remove it from the states variables, and we end up with the following states variables.
\[
	x_{tn} = \begin{bmatrix} s, & n, & \dot{s}, & \dot{n} \end{bmatrix}
\]
We now use the new defined artificial controls inputs, for controlling the system.
\[
	\tilde{u} = \begin{bmatrix} u_t, & u_n \end{bmatrix}
\]
The dynamics are given by:
\begin{equation}
	f(x_{tn}, \tilde{u}) = \begin{bmatrix}
		\dot{s} \\
		\dot{n} \\
		u_t     \\
		u_n     \\
	\end{bmatrix}
	\label{eq:pm_final_dynamics}
\end{equation}

\subsubsection{Constraints}

We have tackled the dynamics constraints of our discrete-time optimal trajectory planning problem \ref{eq:discrete_dynamics}.
Next we are going to define our constraints coupling constraints on the states variables and the controls inputs and see which Problem arise and how
we can deal with them.

Let us first have a look on the vehicle constraints.
Let $\square$ be one of the variables used in trajectory planning, the upper bound is annotated with $\overline{\square}$ and the lower bound with
$\underline{\square}$ which are both constant during planning.

Constraints on the velocity is defined in a body fixed manner, with upper and lower bound, where we use the following annotations.

\begin{align}
	\underline{v_x} \leq v_x \leq \overline{v_x} \\
	\underline{v_y} \leq v_y \leq \overline{v_y}
\end{align}

We can easily apply \ref{eq:first_derivative_lat} and \ref{eq:first_derivative_long} to get resulting constraints on our state variables.
The equations reduce together with $\xi = 0$ to:

\begin{align}
	\underline{v_x}  \leq  \dot{s}(1-nC(s))  \leq  \overline{v_x} \\
	\underline{v_y}  \leq  \dot{n}           \leq  \overline{v_y}
\end{align}

For the acceleration two types of constraints are usually defined, the first one which constrains the relations of the longitudinal and lateral acceleration as:
\begin{equation}
	a_x^2 + a_y^2 \leq c \in \mathbb{R}^+
\end{equation}
for some constant radius $c$, the second similar to the velocity as follows:
\begin{align}
	\underline{a_x} \leq a_x \leq \overline{a_x} \\
	\underline{a_y} \leq a_y \leq \overline{a_y}
\end{align}

Using our derived equations we can define a mapping from the models state variables and artificial variables to our body fixed accelerations.
(TODO: the main paper mentions $a_b = a_{tn}$ which I believe should be \[
	a_b + \begin{bmatrix}
		-\dot{s}(1-nC(s))C(s)\dot{s} \\
		\dot{n}C(s)\dot{s}
	\end{bmatrix} = a_{tn}\])

\begin{align}
	g(x_{tn}, \tilde{u}) :=
	\begin{bmatrix}
		(1 - nC(s)) u_t - (2\dot{n}C(s)\dot{s} + nC' \dot{s}^2) -\dot{s}(1-nC(s))C(s)\dot{s} \\
		u_n + C(s) \dot{s}^2 (1 - nC(s)) +  \dot{n}C(s)\dot{s}
	\end{bmatrix}  = \begin{bmatrix}
		                 a_x \\
		                 a_y
	                 \end{bmatrix}
\end{align}
Combining the constraints on the vehicle derive from the body fixed notion and the straight forward constraint given by the road constraints we can define our coupling constraint set $\mathcal{C}$ as:
\begin{equation}
	\mathcal{C} := \left\{
	\begin{bmatrix} x_{tn} \\ \tilde{u} \end{bmatrix} \; \middle|\;
	\begin{aligned}
		 & \underline{s} \leq s \leq \overline{s},                                     \\
		 & \underline{n}(s) \leq n \leq \overline{n}(s),                               \\
		 & \underline{v_x}  \leq  \dot{s}(1-nC(s))  \leq  \overline{v_x}               \\
		 & \underline{v_y} \leq \dot{n} \leq \overline{v_y}                            \\
		 & \underline{\dot{\psi}} \leq C(s) \dot{s} \leq \overline{\dot{\psi}},        \\
		 & \underline{a_{\psi}} \leq C' \dot{s}^2 + C(s) u_t \leq \overline{a_{\psi}}, \\
		 & \begin{bmatrix}
			   \underline{a_x} \\ \underline{a_y}
		   \end{bmatrix} \leq g(x_{tn}, \tilde{u}) \leq \begin{bmatrix}
			                                                \overline{a_x} \\\overline{a_y}
		                                                \end{bmatrix} \\
		 & ||g(x_{tn}, \tilde{u})||^2 \leq c
	\end{aligned}
	\right\}
\end{equation}

This set is highly non-convex, and we now face the problem to 'convexify' those constraints.
We will do so by finding an inner polytope of the set $\mathcal{C}$ stated as follows.

\subsubsection{Problem Definition: Finding an Inner Polytope}
\label{problem:inner_polytope}
Given set $\mathcal{C}$ over the state variables $x_{tn}$ and control inputs $\tilde{u}$, find $\underline{\mathcal{C}}$, such that:
\begin{equation}
	\underline{\mathcal{C}} = \left\{ \begin{bmatrix}
		x_{tn} \\ \tilde{u} \end{bmatrix} \; \middle|\;
	N \begin{bmatrix}
		x_{tn} \\ \tilde{u} \end{bmatrix} \leq b
	\right\} \subseteq \mathcal{C}
\end{equation}

We will demonstrate two methods how one can archive, both them try to archive the following.

We want to find the set $\tilde{\underline{\mathcal{C}}}$ over the variables $\dot{s}$ and $\tilde{u}$, such that:

\begin{equation}
	\tilde{\underline{\mathcal{C}}} =
	\left\{ \;
	\begin{bmatrix}
		\dot{s} \\
		u_t     \\
		u_n
	\end{bmatrix}
	\middle|\;
	\begin{bmatrix}
		x_{tn} \\ \tilde{u}
	\end{bmatrix} \in \mathcal{C}, \text{for all } \begin{bmatrix}
		s \\
		n \\
		\dot{n}
	\end{bmatrix} \in \begin{bmatrix}
		\underline{s}, \overline{s} \\
		\underline{n}, \overline{n} \\
		\underline{\dot{n}},  \overline{\dot{n}}
	\end{bmatrix}
	\right\}
\end{equation}

To be more specific, we want to find a set of linear constraints, which each spans a half space and let $\tilde{\underline{\mathcal{C}}}$ be
intersection of all those half spaces, then the following should hold.

\begin{equation}
	\label{eq:forall_formula}
	\begin{bmatrix}
		\dot{s} \\
		u_t     \\
		u_n
	\end{bmatrix} \in \tilde{\underline{\mathcal{C}}}
	\implies
	\forall  \begin{bmatrix}
		s \\
		n \\
		\dot{n}
	\end{bmatrix} \in \begin{bmatrix}
		\underline{s}, \overline{s} \\
		\underline{n}, \overline{n} \\
		\underline{\dot{n}},  \overline{\dot{n}}
	\end{bmatrix}: \quad
	\begin{aligned}
		 & (\underline{v_x}  \leq  \dot{s}(1-nC(s))  \leq  \overline{v_x}             & \land \\
		 & \underline{\dot{\psi}} \leq C(s) \dot{s} \leq \overline{\dot{\psi}}        & \land \\
		 & \underline{a_{\psi}} \leq C' \dot{s}^2 + C(s) u_t \leq \overline{a_{\psi}} & \land \\
		 & \begin{bmatrix}
			   \underline{a_x} \\ \underline{a_y}
		   \end{bmatrix} \leq g(x_{tn}, \tilde{u}) \leq \begin{bmatrix}
			                                                \overline{a_x} \\\overline{a_y}
		                                                \end{bmatrix}               & \land   \\
		 & ||g(x_{tn}, \tilde{u})||^2 \leq c )
	\end{aligned}
\end{equation}

The problem therefore reduces to the Elimination of the $\forall$ quantifier.

\subsection{Eliminating the For-All Operator} \label{subsec:eliminating_the_for_all_operator}
\subsubsection{Fitting a Box}

The first approach is the computationally less expensive one, but comes in cost with smaller resulting set, but is it turn it does still perform
really well.
The idea is to find intervals for the variables of interest namely $\dot{s}$, $u_t$ and $u_n$ such that for the values variables may take from those
intervals the implications from \ref{eq:forall_formula} holds.
Each of the condition of that implications follow the following pattern.
Let $x \in \{\dot{s}, u_t, u_n\}$ and $y$ a vector containing the remaining variables are part of the condition.
\begin{equation}
	\label{eq:cur_condition}
	c_{min} \leq f(x, y) \leq c_{max}
\end{equation}
with $x \in \mathbb{R}$, $y \in \mathbb{R}^n$, and $f: \mathbb{R}^{n+1} \to \mathbb{R}$, where $c_{min}, c_{max} \in \mathbb{R}$ are constants.
$x$ is chosen such that all the remaining variables contained in $y$ are bounded.
Further, $x$ is chosen such that $f$ is affine in $x$, represented by:
\begin{equation}
	f(x, y) = a(y) x + b(y)
\end{equation}
with $a, b : \mathbb{R}^n \to \mathbb{R}$, since $a$ and $b$ are continues functions over a bounded domain $Y$ one can find bounds on $a(y)$ and $b(y)$:
\begin{equation}
	a_{min} \leq a(y) \leq a_{max}, \quad b_{min} \leq b(y) \leq b_{max}
\end{equation}
Our goal is to find an interval $[\underline{x}, \overline{x}]$ for $x$ such that
\begin{equation}
	x\in [\underline{x}, \overline{x}] \implies \forall y\in Y: c_{min} \leq f(x, y) \leq c_{max}
\end{equation}

We define $X := [\underline{x}, \overline{x}]$.
We can calculate $X$ with a case distinction over the possible signs $a(y)$ may take.
Let's start with

\textbf{1.
}
$a(y) > 0$:
We can subtract \ref{eq:cur_condition} with $b(y)$ and divide by $a(y)$:
\[
	\frac{c_{min}-b(y)}{a(y)} \leq x \leq \frac{c_{max}-b(y)}{a(y)}
\]
Since we have to ensure the condition holds even in the worst case, $X$ is given by:
\[
	\underline{x} =
	\begin{cases}
		\begin{array}{ll}
			\frac{c_{min}-b_{min}}{a_{max}}, & \text{if } c_{min}-b_{min} < 0 \\[10pt]
			\frac{c_{min}-b_{min}}{a_{min}}, & \text{otherwise}
		\end{array}
	\end{cases}
\]
\[
	\overline{x} =
	\begin{cases}
		\begin{array}{ll}
			\frac{c_{max}-b_{max}}{a_{min}}, & \text{if } c_{max}-b_{max} < 0 \\[10pt]
			\frac{c_{max}-b_{max}}{a_{max}}, & \text{otherwise}
		\end{array}
	\end{cases}
\]

\textbf{2.}
$a(y) \geq 0$:
Since $a(y) = 0$ for some $y\in Y$, we have to test if this condition holds:
\[
	c_{min} \leq b_{min} \text{ and } b_{max} \leq c_{max}
\]
if it does not hold $X$ is given by $X=\emptyset$, and otherwise we exclude all $y\in Y$ for which $a(y)=0$ and go to the first case.

\textbf{3.}
$a(y) < 0$:
We can again subtract $b(y)$ from \ref{eq:cur_condition} and divide by $a(y)$, but the directions of the inequalities changes this time:
\[
	\frac{c_{max}-b(y)}{a(y)} \leq x \leq \frac{c_{min}-b(y)}{a(y)}
\]
and by looking at the worst cases of the lower and upper bound we can calculate $X$:
\[
	\underline{x} =
	\begin{cases}
		\begin{array}{ll}
			\frac{c_{max}-b_{max}}{a_{max}}, & \text{if } c_{max}-b_{max} < 0 \\[10pt]
			\frac{c_{max}-b_{max}}{a_{min}}, & \text{otherwise}
		\end{array}
	\end{cases}
\]
\[
	\overline{x} =
	\begin{cases}
		\begin{array}{ll}
			\frac{c_{min}-b_{min}}{a_{min}}, & \text{if } c_{min}-b_{min} < 0 \\[10pt]
			\frac{c_{min}-b_{min}}{a_{max}}, & \text{otherwise}
		\end{array}
	\end{cases}
\]

\textbf{4.}
$a(y) \leq 0$:
similar to the second case we have to if $c_{min} \leq b_{min} \text{ and } b_{max} \leq c_{max}$ holds, if not $X=\emptyset$ else we ignore the values for $a(y)$ takes the value zero and go to third case.

\textbf{5.}
We have so far considered all the cases where $a(x)$ can not take both positive and negative values, we remain with the last case, where $a_{min}<0$
and $0<a_{max}$.
Since $a(y)=0$ for some values we check $c_{min} \leq b_{min} \text{ and } b_{max} \leq c_{max}$ and set $X=\emptyset$ if it does not hold, otherwise
$X$ is given by:

\[ \underline{x} = \max \left\{ \frac{c_{min} - b_{min}}{a_{max}}, \frac{c_{max} - b_{max}}{a_{min}} \right\} \]

\[ \overline{x} = \min \left\{ \frac{c_{max} - b_{max}}{a_{max}}, \frac{c_{min} - b_{min}}{a_{min}} \right\} \]

If we end up with $x_{max} < x_{min}$, set $X=\emptyset$.

All of this applies nicely to our scenario, since one can go step by step through the constraints and apply these rules.
Of course the resulting Polytope is of a box shape based on the interval approach and therefore reduces our set of possible state variables and
control inputs further.

\textbf{Evaluation of the Inner Polytope}

We start by defining the intervals for the state variables and control inputs:
\begin{align*}
	0  & \leq s \leq 10,     \\
	0  & \leq n \leq 2,      \\
	-2 & \leq \dot{n} \leq 2
\end{align*}

We set $C(s) = \frac{1}{400}$ constant.
Next, we plug in concrete values for the upper and lower bounds of the constraints:
\begin{align*}
	0               & \leq \dot{s}(1 - nC(s)) \leq 10,            \\
	-5              & \leq C(s) \dot{s} \leq 5,                   \\
	-2              & \leq C'(s) \dot{s}^2 + C(s) u_t \leq 2,     \\
	\begin{bmatrix}
		-3 \\ -4
	\end{bmatrix} & \leq g(x_{tn}, \tilde{u}) \leq \begin{bmatrix}
		                                               6 \\ 4
	                                               \end{bmatrix}.
\end{align*}

Applying the approach outlined above, we can determine the intervals for $\dot{s}$, $u_t$, and $u_n$ that satisfy the constraints.
\begin{align*}
	0     & \leq \dot{s} \leq 10 \\
	-2.9  & \leq u_t \leq 5.9    \\
	-3.99 & \leq u_n \leq 3.75
\end{align*}

\subsubsection{Cylindrical Algebraic Decomposition}

% https://pdf.sciencedirectassets.com/272313/1-s2.0-S0747717120X00034/1-s2.0-S0747717119300859/main.pdf?X-Amz-Security-Token=IQoJb3JpZ2luX2VjEGEaCXVzLWVhc3QtMSJHMEUCIQDv1oLeMw%2BnRWE0h7eQREn2av5%2Fyma7r75pKvvjSHlrXwIgV7nFb3g04oCEggSau0SfQkIX7JmFrWaGLYqigDP09qwqvAUIiv%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FARAFGgwwNTkwMDM1NDY4NjUiDLCCP%2B5UfB4z%2F9ZIdiqQBQ7ZhV1OWpdCAEagdXayFOLycbob6NgxpF3z1LcaO5LcnynbNCjIKVBEA2QYuDnScIYeJxkFH6YYFi9ph8XVV3LjzYoAzcX4EU%2B1a1CzJpd2b%2F%2B1b4UukWAcQGXtUYi%2FLRVKDyoNr9CRPVmeu3ELpNmykuQQnJYzCLwsJSUc9ExIdZ8a%2BeQa3cjRFcVni7K%2BnFhH%2Fq%2Fy8P0WW4qt%2F1Hh48UXm2c8wSRTSXpaxOUeZLJzr4WbqT5jUQJsdLwfNCawDcAQrfoDGmtGnKiGS%2B03IulLdq5kKFvEcg8VzoT2zCl2geVu%2BxWFtuwkspvAX%2FVoyRDUeqEpfWkd1Ow2hK%2FFd6xoLEBc6ER4A6leFr5%2FE8wtKfvCDnNqH7G24pUVllhuuT1Vo4GyMHKsbobZbZc9aenU6gpDDoXAc0Pn0JSUTo8zL%2FZCdOqIdVFGbkWPE9sGjWjoFJbHwqudjGZdRYGFekI%2BgsqEu2l1J9AtmTVsr8zLaAQ43%2FUJGR4v8TE%2F05QmO93bo7IkSrsF3OZ4wQPalWuqcyvm6aTa3YsWooRV7q1jc3KMsuMVei9IMFn2gdkUZDATKuYLuZWBs6zwvbVXC0Z7bq6PWH2JHTQdVIxQxsmBSfaV3YOa%2BI3hl5zBNeSAfoDXEEImdqLUsw06mmUvy2IP%2Bzt95a%2FA8Cp9U1yGLmYJZu83DaEnHHVAJ7scbh9c1itOliyghGaTuLzyZi3JbQJB7HW6Put0XOt7zpBHU0NzO7UpQWq%2FTzmHSUSSSkey821Yz%2BFjqciZsQuhzwiOvqHDimSa0kJmeMbpjC5YKax0BOCWjST1UD%2FMnguAu1yTvZS6NrWkCqd7x5bQl3cDg5DSNm2VWTg%2FkZx4JUOZmLxqMKiM0b0GOrEBKzrzEOw7KtIOIpTMjE%2Bs2GvYtsAhgwXJiN5L0r%2FLXqOg6%2B1c%2FNqDSsVeNzrG%2FIH7FgIVEi3BlBViJT9jkjRXQlb0eBFchDzGXKYxs6Cd3S3IOuznUnycfU4IkP5RTiH8ezMEpJ8kCPHRxMrFsjZjLzwTnyBJQrmoztOqL9NSJ7oOjHhKzntHaI9XbPAqb17bMrsnqgR1hppRBXBtCNuJ2CXGgTf8O5OJJSLuZHeyuk1b&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Date=20250218T085718Z&X-Amz-SignedHeaders=host&X-Amz-Expires=300&X-Amz-Credential=ASIAQ3PHCVTYZ3CJJ6RU%2F20250218%2Fus-east-1%2Fs3%2Faws4_request&X-Amz-Signature=773e914dc853ee1f296df8ec3ecf005187519e5ef698f2c1f9146864c5cb004a&hash=1f88efcdfe5ff01d947ced0dcd867ca316abe9378c414f7a661aa7397787d115&host=68042c943591013ac2b2430a89b270f6af2c76d8dfd086a07176afe7c76c2c61&pii=S0747717119300859&tid=spdf-619c46db-0fd6-4248-b3db-2dbf2175b738&sid=3036b6bb946a2440116b8422b092c52ae3aagxrqb&type=client&tsoh=d3d3LnNjaWVuY2VkaXJlY3QuY29t&ua=02075c54500504035f53&rr=913ccf147b209248&cc=de

The second approach is to use Cylindrical Algebraic Decomposition (CAD) to find the inner polytope.
This method is computationally more expensive but provides a more accurate result.
The idea is to find for a given formula (containing quantifier) an equivalent formula without quantifiers, which will contain only the free variables
that are not bound to a quantifier.
This can be done by using CAD.

CAD is a method used in computer algebra for solving systems of polynomial equations and inequalities.
Let's say you have a set of polynomial equations and inequalities.
If one applies CAD to this set, it will decompose the space into a finite number cylindrical cells.
Each cell is described by a sequence of polynomial inequalities.
The cells have the property that they have a constant truth value over the input set of polynomial equations and inequalities.
This way one has to only pick one point from each cell to check the truth value of the input set of polynomial equations and inequalities.
The number of cells grows doubly exponentially with the number of variables in the input set of polynomial equations and inequalities.
For CAD exist several implementations.

We are going to illustrate how the Algorithm works and it is not scope of this work to explain the implementations.
Instead, we are giving you a toolbox how one can do it.

\subsubsection{Example}
Since we are focusing on eliminating $\forall$ quantifiers, we will tackle the following problem:

\[ \forall x, x^2 + bx + 1 \geq
	0 \]

Since the Quantifier Elimination problem is usually done the on an existential quantifier, we first solve the problem for \[
	\exists x, x^2 + bx + 1 < 0 \] and once we have the solution for this problem we can take the compliment over $\mathbb{R}$ to get the solution for
the original problem.
The first thing is to extract is to apply CAD to the polynomial $x^2 + bx + 1$, which results in 7 cells illustrated in the figure
\ref{fig:example_cells}.
Most of the cells are open and if the edge of the cell is part of it then it is depicted dashed with the same color.

\begin{figure}[h]
	\centering
	\definecolor{redviolet}{rgb}{0.78, 0.08, 0.52}
	\begin{tikzpicture}
		\begin{axis}[
				xlabel={$b$},
				ylabel={$x$},
				axis lines=middle,
				enlargelimits=true,
				legend pos=north west,
			]

			% Define the boundaries as paths
			\addplot [name path=RightUpper, domain=2:5, samples=100, thick, redviolet!30, dashed] {-(x/2) + 1/2 * sqrt(-4 + x^2)};
			\addplot [name path=RightLower, domain=2:5, samples=100, thick, teal!30, dashed] {-(x/2) - 1/2 * sqrt(-4 + x^2)};
			\addplot [name path=LeftUpper, domain=-5:-2, samples=100, thick,blue!30, dashed] {-(x/2) + 1/2 * sqrt(-4 + x^2)};
			\addplot [name path=LeftLower, domain=-5:-2, samples=100, thick,cyan!30, dashed] {-(x/2) - 1/2 * sqrt(-4 + x^2)};

			% Define vertical lines as paths but make them invisible
			\addplot [name path=lineInnerRight,dashed, thick,  red!30] coordinates {(2,-5) (2,5)};
			\addplot [name path=lineInnerLeft, dashed, thick, red!30] coordinates {(-2,-5) (-2,5)};

			% Define horizontal boundaries as paths but make them invisible
			\addplot [name path=lineUpperLeft, draw=none] coordinates {(-5,5) (-2,5)};
			\addplot [name path=lineUpperRight, draw=none] coordinates {(2,5) (5,5)};
			\addplot [name path=lineLowerLeft, draw=none] coordinates {(-5,-5) (-2,-5)};
			\addplot [name path=lineLowerRight, draw=none] coordinates {(2,-5) (5,-5)};

			% Region 1: b>2, x >= -(b/2) + 1/2 sqrt(-4 + b^2)
			\addplot [fill=redviolet!30, opacity=0.5] fill between[of=RightUpper and lineUpperRight];

			% % Region 2: b>2, x <= -(b/2) - 1/2 sqrt(-4 + b^2)
			\addplot [fill=teal!30, opacity=0.5] fill between[of=RightLower and lineLowerRight];

			% % Region 3: b<-2, x >= -(b/2) + 1/2 sqrt(-4 + b^2)
			\addplot [fill=blue!30, opacity=0.5] fill between[of=LeftUpper and lineUpperLeft];

			% % Region 4: b<-2, x <= -(b/2) - 1/2 sqrt(-4 + b^2)
			\addplot [fill=cyan!30, opacity=0.5] fill between[of=LeftLower and lineLowerLeft];

			% % Region 5: -2 ≤ b ≤ 2 (rectangle covering all x values)
			\addplot [fill=red!30, opacity=0.5] fill between[of=lineInnerLeft and lineInnerRight];

			% % Region 6: b>2, x > -(b/2) - 1/2 Sqrt[-4+b^2], x < -(b/2) + 1/2 Sqrt[-4+b^2]
			\addplot [fill=cyan!30, opacity=0.3] fill between[of=RightUpper and RightLower];

			% % Region 7: b<-2, x > -(b/2) - 1/2 Sqrt[-4+b^2], x < -(b/2) + 1/2 Sqrt[-4+b^2]
			\addplot [fill=gray!30, opacity=0.3] fill between[of=LeftUpper and LeftLower];

		\end{axis}
	\end{tikzpicture}
	\caption{Illustrating the cells with shaded regions.}
	\label{fig:example_cells}
\end{figure}

We now have to check the truth value of the polynomial inequality $x^2 + bx + 1 < 0$ for each cell, by picking one random sample and evaluating the
inequality.
The cells with a truth value of true colored in green then get project the $b$-axis.
The resulting intervals are the result of the existential quantifier elimination $(-\infty, -2) \cup (2, \infty)$.
As an input of the Algorithm one has to define an order of precedence for the variables.
The algorithm in its first phase projects the space iterative from $\mathbb{R}^n$ to $\mathbb{R}^{n-1}$ until it reaches $\mathbb{R}^1$.
This is done by removing one of the remaining variables in each iteration which is last in the order of precedence.
Therefor if one defines $b$ as the first variable, the sets of polynomial inequalities of each cell will always contain an interval for $b$, which is
the corresponding projection on the axis.
This allows to just read the resulting intervals.

\begin{figure}[h]
	\centering
	\begin{tikzpicture}
		\begin{axis}[
				xlabel={$b$},
				ylabel={$x$},
				axis lines=middle,
				enlargelimits=true,
				legend pos=north west,
			]

			% Define the boundaries as paths
			\addplot [name path=RightUpper, domain=2:5, samples=100, thick, black!30, dashed] {-(x/2) + 1/2 * sqrt(-4 + x^2)};
			\addplot [name path=RightLower, domain=2:5, samples=100, thick, black!30, dashed] {-(x/2) - 1/2 * sqrt(-4 + x^2)};
			\addplot [name path=LeftUpper, domain=-5:-2, samples=100, thick,black!30, dashed] {-(x/2) + 1/2 * sqrt(-4 + x^2)};
			\addplot [name path=LeftLower, domain=-5:-2, samples=100, thick,black!30, dashed] {-(x/2) - 1/2 * sqrt(-4 + x^2)};

			% Define vertical lines as paths but make them invisible
			\addplot [name path=lineInnerRight,dashed, thick,  draw=none] coordinates {(2,-5) (2,5)};
			\addplot [name path=lineInnerLeft, dashed, thick, draw=none] coordinates {(-2,-5) (-2,5)};

			% Define horizontal boundaries as paths but make them invisible
			\addplot [name path=lineUpperLeft, draw=none] coordinates {(-5,5) (-2,5)};
			\addplot [name path=lineUpperRight, draw=none] coordinates {(2,5) (5,5)};
			\addplot [name path=lineLowerLeft, draw=none] coordinates {(-5,-5) (-2,-5)};
			\addplot [name path=lineLowerRight, draw=none] coordinates {(2,-5) (5,-5)};

			% % Region 6: b>2, x > -(b/2) - 1/2 Sqrt[-4+b^2], x < -(b/2) + 1/2 Sqrt[-4+b^2]
			\addplot [fill=green!30, opacity=0.3] fill between[of=RightUpper and RightLower];

			% % Region 7: b<-2, x > -(b/2) - 1/2 Sqrt[-4+b^2], x < -(b/2) + 1/2 Sqrt[-4+b^2]
			\addplot [fill=green!30, opacity=0.3] fill between[of=LeftUpper and LeftLower];

			\node[circle,draw,inner sep=1pt, green!60] (openCircleRight) at (axis cs:2,0) {};
			\draw[thick, green!60] (openCircleRight) -- (axis cs:5.5,0);
			\node[circle,draw,inner sep=1pt, green!60] (openCircleLeft) at (axis cs:-2,0) {};
			\draw[thick, green!60] (openCircleLeft) -- (axis cs:-5.5,0);
		\end{axis}
	\end{tikzpicture}
	\caption{Illustrating the remaining cells.}
	\label{fig:remaining_cells}
\end{figure}

Since $(-\infty, -2) \cup (2, \infty)$ is an equivalent formula for $\exists x, x^2 + bx + 1 < 0$, the solution for the original problem is given by
negotiate both formulas.

\[
	\forall x, x^2 + bx + 1 \geq 0 \iff b \in [-2, 2]
\]

Using this technique for eliminating quantifiers of formulas, we can apply it to our of finding an inner polytope.

\subsubsection{Compare both Approaches}

During our benchmarks, the first approach, despite its simplicity, performed remarkably well.
We used the following parameters for the benchmarks:
\begin{itemize}
	\item $C(s) \in \left[-\frac{1}{200}, 0\right]$
	\item $s \in [0, 10]$
	\item $n \in [0, 2]$
	\item $v_x \in [0, 10]$
	\item $v_y \in [-2, 2]$
	\item $a_x \in [-3, 6]$
	\item $a_y \in [-4, 4]$
	\item $\dot{\psi} \in [-5, 5]$
	\item $a_\psi \in [-2, 2]$
\end{itemize}

The results are shown in the following figures.

\begin{figure}[h]
	\centering
	% First image
	\begin{subfigure}[b]{0.32\textwidth}
		\centering
		\includegraphics[width=\textwidth]{figures/inner_polytope/region_x3u1_plot_gr1.eps}
	\end{subfigure}
	% Second image
	\begin{subfigure}[b]{0.32\textwidth}
		\centering
		\includegraphics[width=\textwidth]{figures/inner_polytope/region_x3u2_plot_gr1.eps}
	\end{subfigure}
	% Third image
	\begin{subfigure}[b]{0.32\textwidth}
		\centering
		\includegraphics[width=\textwidth]{figures/inner_polytope/region_u1u2_plot_gr1.eps}
	\end{subfigure}

	\caption{In Green our first approach and in Blue using CAD.}
\end{figure}

In conclusion, eliminating the quantifiers with the first approach leads to a near-optimal result, comparable to the one achieved using the second
approach with CAD.
However, using CAD has a significant downside that we have not yet mentioned.
It is not guaranteed that the resulting formula is convex.
Typically, you will encounter disjunctions of polynomial inequalities, which cannot be handled by a convex solver without resorting to integer
programming or an equivalent approach.
It is also not guaranteed that each polynomial inequality adheres to the DCP rules, even if the set described by the resulting formula is convex.
Additional techniques would be required to use the second approach for our planner.

In cases where the resulting set is convex, we used a sampling approach to obtain an inner approximation described by half-spaces.
This results in a sequence of linear constraints that all must be satisfied, thus losing a small proportion of the original set.
Consequently, the difference between our first approach and the second approach becomes even smaller.
Additionally, we end up with double or triple the number of constraints on each state variable and each control input, which may lead to slower
solver times.

Overall, while the CAD approach provides a more accurate result, the first approach offers a good balance between computational efficiency and
accuracy, making it a viable option for practical applications.

\subsubsection{Inner Polytope}

We have managed to construct a realistic model, which allows us to model any constraints arising either from the vehicle dynamics or the environment,
such that they are not only confirm with the DCP rules but also linear.

Our inner polytope from the problem \ref{problem:inner_polytope} is now given by:

\begin{equation}
	\label{eq:pm_coupling_constraints}
	\underline{\mathcal{C}} = \tilde{\underline{\mathcal{C}}} \times [\underline{s}, \overline{s}] \times [\underline{n}, \overline{n}] \times [\underline{\dot{n}}, \overline{\dot{n}}]
\end{equation}
with $\tilde{\underline{\mathcal{C}}}$ resulting from $\forall$-elimination.

\subsubsection{Limitations and Outlook}

While the $\forall$-elimination approach provides a computationally efficient method to find intervals for the variables of interest, it can be quite restrictive for several reasons:

\begin{itemize}
	\item \textbf{Conservativeness:}
	      The approach tends to be conservative because it ensures that the constraints hold for all possible values within the intervals.
	      This often leads to smaller intervals, which may exclude feasible solutions that could be considered by less conservative methods.
	\item \textbf{Dependence on Affine Functions:}
	      The method relies on the assumption that the function $f(x, y)$ is affine in $x$.
	      If this assumption does not hold, the approach may not be applicable or may yield inaccurate results.
	\item \textbf{Worst-Case Scenarios:}
	      The intervals are determined based on worst-case scenarios, which can be overly pessimistic and exclude feasible solutions that are not captured by
	      the worst-case analysis.
\end{itemize}

Overall, while the $\forall$-elimination approach is useful for its simplicity and computational efficiency, it may lead to overly restrictive
solutions that do not fully exploit the feasible region.

Imagine your scenario consists of a tight turn and long straight road.
In such scenarios, the model, will restrict $\dot{s}$ to an interval that is valid for both the tight turn and the straight road.
One can easily imagine that model will find a result, but it will not be able to drive fast on the straight road, then it is possible to drive on
tight the turn.

Solving such issues can be done by introducing segments of the road, one for the straight road and one for the tight turn.
We can independently construct the coupling constraints set for each segment.
But this leads to a new Problem, how to switch between the segments.
We have come up with a solution where we use the current vehicle velocity to predict at which time the vehicle will reach the end of the segment.
Since one knows the vehicles current position, velocity and the distance to the end of the segment, one can calculate the time it will take to reach.

What both approaches both do not consider and may lead to a far larger set, if you would restrict $\dot{n}$ for example to a smaller interval.
The first approach handles the problem by using the bounds on $s$, $n$ and $\dot{n}$ to find the intervals for $\dot{s}$, which then is used for
$u_t$ and finally for $u_n$.
But changing the order may lead to better results for desired driving behavior.

Since the first approach is so simple we implemented a non-linear program which defines the relations between the intervals that arise with variables
as upper and lower bounds.
Constraining them additional we can define an objective that can model certain driving behavior.
As for example one should be able to slow down as quickly as possible, or the upper speed limit should as large as possible.
The latter one leads for example to the following intervals.

\begin{figure}[h]
	\centering
	\begin{subfigure}[b]{0.45\textwidth}
		\centering
		\begin{align*}
			0    & \leq s \leq 10       \\
			0    & \leq n \leq 2        \\
			0    & \leq \dot{s} \leq 10 \\
			-2   & \leq \dot{n} \leq 2  \\
			-2.9 & \leq u_t \leq 5.9    \\
			-4   & \leq u_n \leq 3.75
		\end{align*}
		\caption{Initial Approach}
	\end{subfigure}
	\hfill
	\begin{subfigure}[b]{0.45\textwidth}
		\centering
		\begin{align*}
			0      & \leq s \leq 10,         \\
			0      & \leq n \leq 2,          \\
			0      & \leq \dot{s} \leq 10.05 \\
			-2     & \leq \dot{n} \leq 2     \\
			-2.899 & \leq u_t \leq 5.929     \\
			-4     & \leq u_n \leq 3.746
		\end{align*}
		\caption{Using Non-Linear Programming}
	\end{subfigure}
	\caption{Comparison of two sets of intervals for state variables and control inputs.}
\end{figure}

As you can see the intervals on the right could be considered better, since one only loses a bit off longitudinal acceleration, but therefore can
driver faster.

But nevertheless, we managed to build our first vehicle model for motion planning, which can be solved by convex solver.
We will now increase the complexity for the next model, in which we will tackle the problem of introducing a vehicle orientation and a steering angle
during the planning.
This will allow us to get a more realistic trajectory for the vehicle, especially for lower speeds and turns.

\subsection{Determining the Steering Angle} \label{subsec:determining_the_steering_angle}

Given: A car model which has state:

\[
	x_{car} = \begin{bmatrix}
		p_x        \\
		p_y        \\
		\delta     \\
		v          \\
		\psi       \\
		\dot{\psi} \\
		\beta      \\
	\end{bmatrix}
\]
\\
$p_x$ Global Position, $p_y$ Global Postion, $\delta$ Steering Angle, $v$ Velocity, $\psi$ Orientation, $\dot{\psi}$ Yaw Rate, $\beta$ Slip Angle.
\\
and control inputs:
\[
	u_{car} = \begin{bmatrix}
		\dot{\delta} \\
		a            \\
	\end{bmatrix}
\]
\\
$\dot{\delta}$ Steering Angle Rate, $a$ Longitudinal Acceleration
\\
\\
The used planning model has its own state definition $x_{planning}$ and control inputs $u_{planning}$.
\\
\\
A planning model has to provide a mapping from the car states to its states:
\[
	x_{car}\mapsto x_{planning}
\]
\\
and a mapping from its control inputs to the control inputs of the car:
\[
	u_{planning} \mapsto u_{car}
\]

\[
	x_{planning} = \begin{bmatrix}
		s       \\
		n       \\
		\dot{s} \\
		\dot{n} \\
	\end{bmatrix}
\]
\\
($s$, $n$) Frenet Frame Coordinates along the road, ($\dot{s}$, $\dot{n}$) Change of the Frenet Frame Coordinates along the road,

\[
	u_{planning} = \begin{bmatrix}
		u_t \\
		u_n \\
	\end{bmatrix}
\]
\\
$u_t$, $u_n$ artificial control inputs, which can be mapped ($a_{s}$, $a_{n}$) Acceleration of the Frenet Frame Coordinates along the road using $g$.

\[
	x_{car} = \begin{bmatrix}
		p_x        \\
		p_y        \\
		\delta     \\
		v          \\
		\psi       \\
		\dot{\psi} \\
		\beta      \\
	\end{bmatrix} \mapsto \begin{bmatrix}
		self.road.get\_road\_position(x, y)[0] \\
		self.road.get\_road\_position(x, y)[1] \\
		v \cos(\psi - \theta(s))               \\
		v \sin(\psi - \theta(s))               \\
	\end{bmatrix}
\]
\\
For control input we additional require the current state $x = [s, n, \dot{s}, \dot{n}]^T$ of the planning model and we need to store the current steering angle of the car $\delta_{cur}$:

\subsubsection{Approach 1}

\[
	\xi = \arctan(\frac{\dot{n}}{\dot{s} (1 - n C(s))})
\]
\[
	v = \sqrt{(\dot{s} (1 - n C(s)))^2 + \dot{n}^2}
\]
\[
	\dot{\psi} = \frac{u_n - \tan(\xi) u_t}{v (\tan(\xi) \sin(\xi) + \cos(\xi))}
\]

\[
	a = \frac{u_t + v \dot{\psi} \sin(\xi)}{\cos(\xi)}
\]
\[
	\dot{C} = \dot{C}(s) = C'(s)\dot{s} \approx \frac{C(s + \dot{s} \Delta t) - C(s)}{\Delta t}
\]
\[
	\dot{\xi} = \frac{1}{1 + (\frac{\dot{n}}{\dot{s} (1 - n C(s))})^2} \frac{u_n \dot{s} (1 - n C(s)) - \dot{n} (u_t - C(s) (u_t n + \dot{s} \dot{n}) - \dot{C} \dot{s} n)}{(\dot{s} (1 - n C(s)))^2}
\]
\[
	\delta = \arctan((\dot{\xi} + C(s) \dot{s}) \frac{l_{wb}}{v})
\]
\[
	v_\delta = \max(\min(\frac{\delta - \delta_{cur}}{\Delta t}, \overline{v_\delta}), \underline{v_\delta})
\]

\[
	u_{planning}, x_{planning} \mapsto \begin{bmatrix}
		v_\delta \\
		a        \\
	\end{bmatrix} = \begin{bmatrix}
		\dot{\delta} \\
		a            \\
	\end{bmatrix}
\]

\subsubsection{Approach 2}

\[
	[s_0, n_0, \dot{s}_0, \dot{n}_0]^T := [s, n, \dot{s}, \dot{n}]^T
\]

\[
	[s _1, n _1, \dot{s} _1, \dot{n} _1]^T := \begin{bmatrix}
		s_0       \\
		n_0       \\
		\dot{s}_0 \\
		\dot{n}_0 \\
	\end{bmatrix} + \Delta t \begin{bmatrix}
		\dot{s}_0 \\
		\dot{n}_0 \\
		u_n       \\
		u_t       \\
	\end{bmatrix}
\]

\[
	v_0 = \sqrt(\dot{s}_0^2 + \dot{n}_0^2)
\]

\[
	v_1 = \sqrt(\dot{s}_1^2 + \dot{n}_1^2)
\]

\[
	a = \frac{v_1 - v_0}{\Delta t}
\]

\[
	v_\delta = \arctan(l_{wb} (planned_psi_2 - (cur_psi + 1/l_wb * v_0 * np.tan(cur_steering_angle) * dt)) / (v_1 * dt)) / dt
\]

\pagebreak

\[
	x_1 = \begin{bmatrix}
		s_1 \\ n_1 \\ \dot{s}_1 \\ \dot{n}_1 \\
	\end{bmatrix} = x_0 + \begin{bmatrix}
		\dot{s}_0 \\ \dot{n}_0 \\ u_t \\ u_n
	\end{bmatrix} dt
\]

\[
	\begin{bmatrix}
		a_s \\
		a_n \\
	\end{bmatrix} = g(u_t, u_n)
\]

\[
	\begin{aligned}
		\xi_0 & = \arctan\left(\frac{\dot{n}_0}{\dot{s}_0}\right) \\
		\xi_1 & = \arctan\left(\frac{\dot{n}_1}{\dot{s}_1}\right)
	\end{aligned}
\]

\[
	\begin{aligned}
		v_0 & = \sqrt{\dot{s}_0^2 + \dot{n}_0^2} \\
		v_1 & = \sqrt{\dot{s}_1^2 + \dot{n}_1^2}
	\end{aligned}
\]

\[
	\begin{aligned}
		\psi_0 & = \xi_0 + \theta(s_0) \\
		\psi_1 & = \xi_1 + \theta(s_1)
	\end{aligned}
\]

\[
	\dot{\psi} = \frac{\psi_1 - \psi_0}{dt}
\]

\[
	u_{planning}, x_{planning} \mapsto \frac{1}{dt} \begin{bmatrix}
		\arctan(l_{wb}\frac{\dot{\psi}}{v_1})-\delta_{cur} \\
		v_1 - v_0                                          \\
	\end{bmatrix} = \begin{bmatrix}
		\dot{\delta} \\
		a            \\
	\end{bmatrix}
\]

\subsection{Final Model} \label{subsec:pm_resulting_model}